import pandas as pd
from दाक्षिलिपीहिन्दी import *
import math
from functools import lru_cache

# =============================================================================
# मूल सहायक सर्ग (Basic Helper Functions)
# =============================================================================

def पदस्थान(a_list, value):
    try:
        return a_list.index(value)
    except ValueError:
        return None

def श्रेणिमेंप्रथमसमीकरणपुष्टीक्रमांक(श्रेणिपात्र, समीकरणपात्र):
  return next((क्रमांक for क्रमांक, पद in enumerate(श्रेणिपात्र) if समीकरणपात्र(पद)), None)

def सारिणी(क):
    if  len(क) == 0: return None
    फल = pd.DataFrame(क, index=क्रमश्रेणी(1, len (क)+1), columns = क्रमश्रेणी( 1,len(क[0])+1 ))
    return फल

def दर्शयसारिणी(क):
    दर्शय(सारिणी(क))


# =============================================================================
# पिंगल छन्दःशास्त्र षट् प्रत्ययाः (Pingala's Six Pratyayas)
# =============================================================================

# प्रतीक परिभाषा
ग = '§'  # गुरु (heavy syllable)
ल = '|'  # लघु (light syllable)
गल = [[ग], [ल]]


def पिंगलप्रस्तार(स्थान, पूर्वफल=None):
    """
    प्रथम प्रत्यय - प्रस्तार (Enumeration)
    सभी छन्दों की सूची क्रमबद्ध रूप में।

    Parameters:
    -----------
    स्थान : int
        अक्षरों की संख्या (number of syllables)
    पूर्वफल : list, optional
        पूर्व परिणाम (for recursion)

    Returns:
    --------
    list : सभी छन्दों की सूची
    """
    if पूर्वफल is None:
        पूर्वफल = [[ग], [ल]]

    if स्थान < 1:
        return None
    if स्थान == 1:
        return पूर्वफल

    फलपात्र = []
    फलपात्र += list(map(lambda पंक्ति: पंक्ति + [ग], पूर्वफल))
    फलपात्र += list(map(lambda पंक्ति: पंक्ति + [ल], पूर्वफल))

    return पिंगलप्रस्तार(स्थान-1, फलपात्र)


def नष्ट(क्रमांक, स्थान):
    """
    द्वितीय प्रत्यय - नष्ट (Index to Pattern)
    क्रमांक से छन्द प्राप्त करना।

    Algorithm: क्रमांक को द्विआधारी में बदलकर ग/ल में मैप करना

    Parameters:
    -----------
    क्रमांक : int
        1 से आरम्भ होने वाला क्रम संख्या (1-indexed)
    स्थान : int
        अक्षरों की संख्या

    Returns:
    --------
    list : छन्द प्रतिरूप [ग/ल, ...]

    Example:
    --------
    >>> नष्ट(1, 3)
    ['§', '§', '§']
    >>> नष्ट(8, 3)
    ['|', '|', '|']
    """
    if क्रमांक < 1 or क्रमांक > 2**स्थान:
        return None

    # 1-indexed to 0-indexed
    मान = क्रमांक - 1

    # द्विआधारी रूपान्तरण (Binary conversion)
    छन्द = []
    for _ in range(स्थान):
        if मान % 2 == 0:
            छन्द.append(ग)
        else:
            छन्द.append(ल)
        मान //= 2

    return छन्द


def नष्ट_चरण(क्रमांक, स्थान):
    """
    नष्ट प्रत्यय का चरण-दर-चरण प्रदर्शन।
    शैक्षणिक उद्देश्य हेतु।

    Returns:
    --------
    dict : चरणों का विवरण
    """
    if क्रमांक < 1 or क्रमांक > 2**स्थान:
        return None

    मान = क्रमांक - 1
    चरण = []
    छन्द = []

    for i in range(स्थान):
        भागफल = मान // 2
        शेष = मान % 2
        अक्षर = ग if शेष == 0 else ल

        चरण.append({
            'स्थान': i + 1,
            'मान': मान,
            'भागफल': भागफल,
            'शेष': शेष,
            'अक्षर': अक्षर
        })

        छन्द.append(अक्षर)
        मान = भागफल

    return {
        'क्रमांक': क्रमांक,
        'स्थान': स्थान,
        'चरण': चरण,
        'छन्द': छन्द
    }


def उद्दिष्ट(छन्द):
    """
    तृतीय प्रत्यय - उद्दिष्ट (Pattern to Index)
    छन्द से उसका क्रमांक ज्ञात करना।

    Algorithm: ग/ल को द्विआधारी में बदलकर दशमलव में परिवर्तन

    Parameters:
    -----------
    छन्द : list
        छन्द प्रतिरूप [ग/ल, ...]

    Returns:
    --------
    int : प्रस्तार में क्रमांक (1-indexed)

    Example:
    --------
    >>> उद्दिष्ट(['§', '§', '§'])
    1
    >>> उद्दिष्ट(['|', '|', '|'])
    8
    """
    क्रमांक = 0
    गुणक = 1

    for अक्षर in छन्द:
        if अक्षर == ल:
            क्रमांक += गुणक
        गुणक *= 2

    return क्रमांक + 1  # 1-indexed


def संख्या(स्थान):
    """
    चतुर्थ प्रत्यय - संख्या (Total Count)
    n स्थानों वाले कुल छन्दों की संख्या।

    Formula: 2^n

    Parameters:
    -----------
    स्थान : int
        अक्षरों की संख्या

    Returns:
    --------
    int : कुल छन्द संख्या

    Example:
    --------
    >>> संख्या(3)
    8
    >>> संख्या(4)
    16
    """
    return 2 ** स्थान


@lru_cache(maxsize=1000)
def द्विपदगुणांक(n, k):
    """
    द्विपद गुणांक C(n,k) की गणना।
    Binomial coefficient calculation.

    Formula: n! / (k! × (n-k)!)
    """
    if k < 0 or k > n:
        return 0
    if k == 0 or k == n:
        return 1
    return द्विपदगुणांक(n-1, k-1) + द्विपदगुणांक(n-1, k)


def लघुक्रिया(स्थान, लघु_संख्या):
    """
    पञ्चम प्रत्यय - लघु-क्रिया (Count by Syllable Type)
    n स्थानों में k लघु अक्षरों वाले छन्दों की संख्या।

    Formula: C(n, k) = n! / (k! × (n-k)!)

    Parameters:
    -----------
    स्थान : int
        कुल अक्षरों की संख्या (n)
    लघु_संख्या : int
        लघु अक्षरों की संख्या (k)

    Returns:
    --------
    int : ऐसे छन्दों की संख्या

    Example:
    --------
    >>> लघुक्रिया(4, 2)  # 4 में से 2 लघु
    6
    """
    return द्विपदगुणांक(स्थान, लघु_संख्या)


def लघुक्रिया_सारिणी(स्थान):
    """
    लघु-क्रिया प्रत्यय की पूर्ण सारिणी।

    Returns:
    --------
    DataFrame : लघु संख्या और विकल्प संख्या
    """
    data = []
    for k in range(स्थान + 1):
        data.append({
            'लघु_संख्या': k,
            'गुरु_संख्या': स्थान - k,
            'विकल्प_संख्या': लघुक्रिया(स्थान, k)
        })
    return pd.DataFrame(data)


def मेरु(पंक्ति_संख्या):
    """
    षष्ठ प्रत्यय - मेरु प्रस्तार (Pascal's Triangle)
    द्विपद गुणांकों का त्रिभुजाकार प्रदर्शन।

    Properties:
    - पंक्ति n में C(n,0) से C(n,n) तक
    - प्रत्येक संख्या = ऊपर की दो संख्याओं का योग
    - Cellular automata (Rule 60) से सम्बन्ध
    - Sierpinski triangle pattern (mod 2)

    Parameters:
    -----------
    पंक्ति_संख्या : int
        मेरु की पंक्तियों की संख्या

    Returns:
    --------
    list : मेरु की पंक्तियाँ

    Example:
    --------
    >>> मेरु(5)
    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]
    """
    if पंक्ति_संख्या < 1:
        return None

    त्रिभुज = [[1]]

    for i in range(1, पंक्ति_संख्या):
        पूर्व = त्रिभुज[-1]
        नवीन = [1]
        for j in range(len(पूर्व) - 1):
            नवीन.append(पूर्व[j] + पूर्व[j + 1])
        नवीन.append(1)
        त्रिभुज.append(नवीन)

    return त्रिभुज


def मेरु_पंक्ति(n):
    """
    मेरु की n-वीं पंक्ति (0-indexed)।
    """
    return [द्विपदगुणांक(n, k) for k in range(n + 1)]


# =============================================================================
# आर्यभटीय गणित (Aryabhatiya Mathematics)
# =============================================================================

def वर्गमूल(संख्या):
    """
    आर्यभट की वर्गमूल विधि।
    Digit-by-digit square root extraction.

    Parameters:
    -----------
    संख्या : int
        जिसका वर्गमूल चाहिए

    Returns:
    --------
    tuple : (वर्गमूल, शेष)
    """
    if संख्या < 0:
        return None
    if संख्या == 0:
        return (0, 0)

    # Newton-Raphson method for integer square root
    x = संख्या
    y = (x + 1) // 2
    while y < x:
        x = y
        y = (x + संख्या // x) // 2

    शेष = संख्या - x * x
    return (x, शेष)


def वर्गमूल_चरण(संख्या):
    """
    वर्गमूल का चरण-दर-चरण प्रदर्शन।
    """
    चरण = []
    x = संख्या
    y = (x + 1) // 2

    चरण.append({'अनुमान': y, 'संख्या': संख्या})

    while y < x:
        x = y
        y = (x + संख्या // x) // 2
        चरण.append({'अनुमान': y, 'पूर्व': x})

    return {
        'मूल': x,
        'शेष': संख्या - x * x,
        'चरण': चरण
    }


def घनमूल(संख्या):
    """
    आर्यभट की घनमूल विधि।
    Cube root extraction.

    Parameters:
    -----------
    संख्या : int
        जिसका घनमूल चाहिए

    Returns:
    --------
    tuple : (घनमूल, शेष)
    """
    if संख्या < 0:
        चिह्न = -1
        संख्या = -संख्या
    else:
        चिह्न = 1

    if संख्या == 0:
        return (0, 0)

    # Newton-Raphson for integer cube root
    x = संख्या
    y = (2 * x + 1) // 3
    while y < x:
        x = y
        y = (2 * x + संख्या // (x * x)) // 3

    शेष = संख्या - x * x * x
    return (चिह्न * x, शेष)


def कुट्टक(a, b, c=None):
    """
    कुट्टक विधि - रैखिक अनिर्धार्य समीकरण।
    Linear Diophantine equation: ax + by = c

    यदि c दिया नहीं, तो ax ≡ 1 (mod b) का हल (modular inverse)

    Parameters:
    -----------
    a : int
        प्रथम गुणांक (भाज्य)
    b : int
        द्वितीय गुणांक (भाजक)
    c : int, optional
        दायाँ पक्ष मान

    Returns:
    --------
    dict : हल {x, y, gcd} या None यदि हल नहीं
    """
    # Extended Euclidean Algorithm
    def विस्तृत_युक्लिड(a, b):
        if b == 0:
            return a, 1, 0
        else:
            g, x, y = विस्तृत_युक्लिड(b, a % b)
            return g, y, x - (a // b) * y

    g, x, y = विस्तृत_युक्लिड(abs(a), abs(b))

    if a < 0:
        x = -x
    if b < 0:
        y = -y

    if c is None:
        c = 1

    if c % g != 0:
        return None  # No solution

    गुणक = c // g

    return {
        'x': x * गुणक,
        'y': y * गुणक,
        'gcd': g,
        'a': a,
        'b': b,
        'c': c
    }


def कुट्टक_चरण(a, b):
    """
    कुट्टक का चरण-दर-चरण प्रदर्शन।
    Extended Euclidean algorithm steps.
    """
    चरण = []

    while b != 0:
        भागफल = a // b
        शेष = a % b
        चरण.append({
            'भाज्य': a,
            'भाजक': b,
            'भागफल': भागफल,
            'शेष': शेष
        })
        a, b = b, शेष

    return {
        'gcd': a,
        'चरण': चरण
    }


# =============================================================================
# ज्या गणित (Trigonometry - Aryabhata's Method)
# =============================================================================

def ज्या_सारिणी(विभाजन=24):
    """
    आर्यभट की ज्या सारिणी।
    Sine table using Aryabhata's difference method.

    त्रिज्या (R) = 3438 (आर्यभट का मान)

    Parameters:
    -----------
    विभाजन : int
        90° के विभाजनों की संख्या (आर्यभट ने 24 प्रयोग किया)

    Returns:
    --------
    DataFrame : कोण और ज्या मान
    """
    import numpy as np

    त्रिज्या = 3438  # Aryabhata's value

    data = []
    for i in range(विभाजन + 1):
        कोण = 90 * i / विभाजन
        ज्या_आधुनिक = np.sin(np.radians(कोण))
        ज्या_आर्यभट = round(त्रिज्या * ज्या_आधुनिक)

        data.append({
            'क्रम': i,
            'कोण_अंश': कोण,
            'ज्या_आर्यभट': ज्या_आर्यभट,
            'ज्या_आधुनिक': round(ज्या_आधुनिक, 6)
        })

    return pd.DataFrame(data)


# =============================================================================
# लीलावती गणित (Lilavati Mathematics)
# =============================================================================

def समान्तर_श्रेणी(प्रथम_पद, सार्वान्तर, पद_संख्या):
    """
    समान्तर श्रेणी (Arithmetic Progression)।

    Parameters:
    -----------
    प्रथम_पद : float
        प्रथम पद (a)
    सार्वान्तर : float
        सार्वान्तर (d)
    पद_संख्या : int
        पदों की संख्या (n)

    Returns:
    --------
    dict : श्रेणी, अन्तिम पद, योगफल
    """
    श्रेणी = [प्रथम_पद + i * सार्वान्तर for i in range(पद_संख्या)]
    अन्तिम_पद = श्रेणी[-1]
    योगफल = पद_संख्या * (प्रथम_पद + अन्तिम_पद) / 2

    return {
        'श्रेणी': श्रेणी,
        'अन्तिम_पद': अन्तिम_पद,
        'योगफल': योगफल,
        'सूत्र': f'aₙ = {प्रथम_पद} + (n-1)×{सार्वान्तर}'
    }


def गुणोत्तर_श्रेणी(प्रथम_पद, गुणोत्तर, पद_संख्या):
    """
    गुणोत्तर श्रेणी (Geometric Progression)।

    Parameters:
    -----------
    प्रथम_पद : float
        प्रथम पद (a)
    गुणोत्तर : float
        सार्वगुणोत्तर (r)
    पद_संख्या : int
        पदों की संख्या (n)

    Returns:
    --------
    dict : श्रेणी, अन्तिम पद, योगफल
    """
    श्रेणी = [प्रथम_पद * (गुणोत्तर ** i) for i in range(पद_संख्या)]
    अन_तिम_पद = श्रेणी[-1]

    if गुणोत्तर == 1:
        योगफल = प्रथम_पद * पद_संख्या
    else:
        योगफल = प्रथम_पद * (गुणोत्तर ** पद_संख्या - 1) / (गुणोत्तर - 1)

    return {
        'श्रेणी': श्रेणी,
        'अन्तिम_पद': अन_तिम_पद,
        'योगफल': योगफल,
        'सूत्र': f'aₙ = {प्रथम_पद} × {गुणोत्तर}^(n-1)'
    }


def क्रमगुणित(n):
    """
    क्रमगुणित (Factorial) n!
    """
    if n < 0:
        return None
    if n <= 1:
        return 1
    return n * क्रमगुणित(n - 1)


def क्रमचय(n, r):
    """
    क्रमचय (Permutation) P(n,r) = n!/(n-r)!
    """
    if r > n or r < 0:
        return 0
    return क्रमगुणित(n) // क्रमगुणित(n - r)


def संचय(n, r):
    """
    संचय (Combination) C(n,r) = n!/[r!(n-r)!]
    """
    return द्विपदगुणांक(n, r)


def चक्रवाल(N, लक्ष्य=1):
    """
    चक्रवाल विधि - पेल समीकरण का हल।
    Chakravala method for x² - Ny² = 1

    Parameters:
    -----------
    N : int
        समीकरण का गुणांक (non-perfect square)
    लक्ष्य : int
        दायाँ पक्ष (usually 1)

    Returns:
    --------
    dict : {x, y} solution or None
    """
    import math

    # Check if N is a perfect square
    sqrt_n = int(math.sqrt(N))
    if sqrt_n * sqrt_n == N:
        return None  # No solution for perfect squares

    # Initial values
    m = 1
    k = 1
    a = sqrt_n

    चरण = []

    # Iterate until k = 1
    max_iterations = 1000
    for _ in range(max_iterations):
        # Find m' that minimizes |m'² - N|
        m_new = k * a - m

        # Adjust m_new to be closest to sqrt(N)
        q = (sqrt_n + m_new) // abs(k)
        m_candidates = [q * abs(k) - m_new, (q + 1) * abs(k) - m_new]

        m_new = min(m_candidates, key=lambda x: abs(x * x - N))

        # Calculate new values using Brahmagupta-Bhaskara identity
        a_new = (a * m_new + N * 1) // abs(k)
        k_new = (m_new * m_new - N) // k

        चरण.append({
            'm': m_new,
            'k': k_new,
            'a': a_new
        })

        m, k, a = m_new, k_new, a_new

        if k == 1:
            # Solution found
            return {
                'x': a,
                'y': m,
                'N': N,
                'चरण': चरण,
                'सत्यापन': a * a - N * m * m
            }
        elif k == -1:
            # Need to compose with itself
            x = a * a + N * m * m
            y = 2 * a * m
            return {
                'x': x,
                'y': y,
                'N': N,
                'चरण': चरण,
                'सत्यापन': x * x - N * y * y
            }

    return None


# =============================================================================
# शुल्बसूत्र रेखागणित (Sulbasutra Geometry)
# =============================================================================

def बौधायन_वर्गमूल_दो():
    """
    बौधायन का √2 सन्निकटन।
    √2 ≈ 1 + 1/3 + 1/(3×4) - 1/(3×4×34) = 577/408
    """
    सन्निकटन = 1 + 1/3 + 1/12 - 1/408
    भिन्न = (577, 408)
    सही_मान = 2 ** 0.5
    त्रुटि = abs(सन्निकटन - सही_मान)

    return {
        'सन्निकटन': सन्निकटन,
        'भिन्न_रूप': भिन्न,
        'सही_मान': सही_मान,
        'त्रुटि': त्रुटि,
        'शुद्धता_अंक': -math.log10(त्रुटि) if त्रुटि > 0 else float('inf')
    }


def पाइथागोरस_त्रिक_उत्पादक(सीमा=20):
    """
    पाइथागोरस त्रिक (Pythagorean triples) उत्पन्न करता है।
    बौधायन शुल्बसूत्र में उल्लिखित।

    Parameters:
    -----------
    सीमा : int
        m, n की अधिकतम सीमा

    Returns:
    --------
    list : त्रिकों की सूची [(a, b, c), ...]
    """
    त्रिक = []

    for m in range(2, सीमा):
        for n in range(1, m):
            if (m - n) % 2 == 1 and math.gcd(m, n) == 1:
                a = m * m - n * n
                b = 2 * m * n
                c = m * m + n * n
                त्रिक.append(tuple(sorted([a, b, c])))

    return sorted(set(त्रिक))


def क्षेत्रफल_त्रिभुज(a, b, c):
    """
    हेरॉन सूत्र द्वारा त्रिभुज का क्षेत्रफल।

    Parameters:
    -----------
    a, b, c : float
        त्रिभुज की भुजाएँ

    Returns:
    --------
    float : क्षेत्रफल
    """
    s = (a + b + c) / 2

    if s <= a or s <= b or s <= c:
        return None  # Invalid triangle

    return math.sqrt(s * (s - a) * (s - b) * (s - c))


def क्षेत्रफल_चक्रीय_चतुर्भुज(a, b, c, d):
    """
    ब्रह्मगुप्त सूत्र द्वारा चक्रीय चतुर्भुज का क्षेत्रफल।
    K = √[(s-a)(s-b)(s-c)(s-d)]

    Parameters:
    -----------
    a, b, c, d : float
        चतुर्भुज की भुजाएँ

    Returns:
    --------
    float : क्षेत्रफल
    """
    s = (a + b + c + d) / 2

    product = (s - a) * (s - b) * (s - c) * (s - d)

    if product < 0:
        return None

    return math.sqrt(product)


# =============================================================================
# ज्योतिष गणित (Astronomical Calculations)
# =============================================================================

def तिथि_गणना(चन्द्र_रेखांश, सूर्य_रेखांश):
    """
    तिथि की गणना।
    तिथि = (चन्द्र रेखांश - सूर्य रेखांश) / 12°

    Parameters:
    -----------
    चन्द्र_रेखांश : float
        चन्द्रमा का रेखांश (0-360)
    सूर्य_रेखांश : float
        सूर्य का रेखांश (0-360)

    Returns:
    --------
    dict : तिथि और पक्ष
    """
    अन्तर = (चन्द्र_रेखांश - सूर्य_रेखांश) % 360
    तिथि = int(अन्तर / 12) + 1

    if तिथि <= 15:
        पक्ष = 'शुक्ल'
        तिथि_नाम = ['प्रतिपदा', 'द्वितीया', 'तृतीया', 'चतुर्थी', 'पञ्चमी',
                    'षष्ठी', 'सप्तमी', 'अष्टमी', 'नवमी', 'दशमी',
                    'एकादशी', 'द्वादशी', 'त्रयोदशी', 'चतुर्दशी', 'पूर्णिमा'][तिथि - 1]
    else:
        पक्ष = 'कृष्ण'
        तिथि_idx = तिथि - 16
        if तिथि_idx < 14:
            तिथि_नाम = ['प्रतिपदा', 'द्वितीया', 'तृतीया', 'चतुर्थी', 'पञ्चमी',
                        'षष्ठी', 'सप्तमी', 'अष्टमी', 'नवमी', 'दशमी',
                        'एकादशी', 'द्वादशी', 'त्रयोदशी', 'चतुर्दशी'][तिथि_idx]
        else:
            तिथि_नाम = 'अमावस्या'

    return {
        'तिथि_क्रम': तिथि,
        'तिथि_नाम': तिथि_नाम,
        'पक्ष': पक्ष,
        'चन्द्र_कला': अन्तर / 12
    }


def नक्षत्र_गणना(चन्द्र_रेखांश):
    """
    नक्षत्र की गणना।
    27 नक्षत्र = 360°, प्रत्येक = 13°20'

    Parameters:
    -----------
    चन्द्र_रेखांश : float
        चन्द्रमा का रेखांश (0-360)

    Returns:
    --------
    dict : नक्षत्र नाम और पाद
    """
    नक्षत्र_सूची = [
        'अश्विनी', 'भरणी', 'कृत्तिका', 'रोहिणी', 'मृगशिरा', 'आर्द्रा',
        'पुनर्वसु', 'पुष्य', 'आश्लेषा', 'मघा', 'पूर्वाफाल्गुनी', 'उत्तराफाल्गुनी',
        'हस्त', 'चित्रा', 'स्वाति', 'विशाखा', 'अनुराधा', 'ज्येष्ठा',
        'मूल', 'पूर्वाषाढ़ा', 'उत्तराषाढ़ा', 'श्रवण', 'धनिष्ठा', 'शतभिषा',
        'पूर्वाभाद्रपद', 'उत्तराभाद्रपद', 'रेवती'
    ]

    नक्षत्र_अंश = 360 / 27  # 13.333...
    नक्षत्र_क्रम = int(चन्द्र_रेखांश / नक्षत्र_अंश)
    पाद = int((चन्द्र_रेखांश % नक्षत्र_अंश) / (नक्षत्र_अंश / 4)) + 1

    return {
        'नक्षत्र_क्रम': नक्षत्र_क्रम + 1,
        'नक्षत्र_नाम': नक्षत्र_सूची[नक्षत्र_क्रम],
        'पाद': पाद
    }


# =============================================================================
# ब्रह्मगुप्त गणित (Brahmagupta's Mathematics)
# =============================================================================

def शून्य_नियम():
    """
    ब्रह्मगुप्त के शून्य सम्बन्धी नियम।
    """
    return {
        'योग': 'a + 0 = a',
        'अन्तर': 'a - 0 = a',
        'गुणन': 'a × 0 = 0',
        'भाग': '0 ÷ a = 0 (यदि a ≠ 0)',
        'शून्य_से_भाग': 'a ÷ 0 = अनन्त (अपरिभाषित)',
        'टिप्पणी': 'ब्रह्मगुप्त ने 0 ÷ 0 = 0 माना, जो आधुनिक गणित में अपरिभाषित है।'
    }


def ऋण_नियम():
    """
    ब्रह्मगुप्त के ऋण संख्या सम्बन्धी नियम।
    धन = positive, ऋण = negative
    """
    return {
        'धन_गुणन': '(+) × (+) = (+)',
        'ऋण_गुणन': '(-) × (-) = (+)',
        'मिश्र_गुणन': '(+) × (-) = (-)',
        'धन_धन': 'धन का वर्ग = धन',
        'ऋण_ऋण': 'ऋण का वर्ग = धन',
        'उदाहरण': [
            '3 × 4 = 12',
            '(-3) × (-4) = 12',
            '3 × (-4) = -12',
            '(-3)² = 9'
        ]
    }


# =============================================================================
# भरत-केदार-हेमचन्द्र प्रस्तार (Alternative Prastaara methods)
# =============================================================================

def प्रस्तारप्रष्ठपंक्ती(दत्तपंक्ती):
    """
    अगली पंक्ति उत्पन्न करना (भरत-केदार विधि)।
    """
    गस्थान = पदस्थान(दत्तपंक्ती, ग)
    if गस्थान is None:
        return None
    फलपंक्ती = [ग] * गस्थान + [ल] + दत्तपंक्ती[गस्थान + 1:]
    return फलपंक्ती


def भरतकेदारप्रस्तार(स्थान):
    """
    भरत-केदार विधि से प्रस्तार।
    """
    नवपंक्ती = [ग] * स्थान
    फल = []
    while नवपंक्ती is not None:
        फल.append(नवपंक्ती)
        नवपंक्ती = प्रस्तारप्रष्ठपंक्ती(नवपंक्ती)
    return फल


# =============================================================================
# महावीर गणित (Mahavira's Mathematics)
# =============================================================================

def महावीर_परिधि(a, b):
    """
    महावीर का दीर्घवृत्त परिधि सूत्र।
    Mahavira's ellipse perimeter: P ≈ √(24b² + 16a²)

    Parameters:
    -----------
    a : float
        दीर्घ अर्ध-अक्ष (semi-major axis)
    b : float
        लघु अर्ध-अक्ष (semi-minor axis)

    Returns:
    --------
    float : परिधि का सन्निकटन
    """
    return math.sqrt(24 * b * b + 16 * a * a)


def रामानुजन_परिधि_1(a, b):
    """
    रामानुजन का प्रथम परिधि सूत्र।
    P ≈ π[3(a+b) - √((3a+b)(a+3b))]

    Parameters:
    -----------
    a, b : float
        अर्ध-अक्ष

    Returns:
    --------
    float : परिधि
    """
    return math.pi * (3 * (a + b) - math.sqrt((3 * a + b) * (a + 3 * b)))


def रामानुजन_परिधि_2(a, b):
    """
    रामानुजन का द्वितीय (अत्यधिक शुद्ध) परिधि सूत्र।
    P ≈ π(a+b)[1 + 3h/(10 + √(4 - 3h))]
    जहाँ h = (a-b)²/(a+b)²

    Parameters:
    -----------
    a, b : float
        अर्ध-अक्ष

    Returns:
    --------
    float : परिधि
    """
    h = ((a - b) ** 2) / ((a + b) ** 2)
    return math.pi * (a + b) * (1 + (3 * h) / (10 + math.sqrt(4 - 3 * h)))


# =============================================================================
# गोलाध्याय (Spherical Trigonometry - Siddhanta Shiromani)
# =============================================================================

def गोलीय_त्रिभुज_नियम(a, b, c, A, B, C, नियम='साइन'):
    """
    गोलीय त्रिभुज के नियम।
    Spherical triangle laws.

    Parameters:
    -----------
    a, b, c : float
        भुजाएँ (radians में)
    A, B, C : float
        कोण (radians में)
    नियम : str
        'साइन' या 'कोसाइन'

    Returns:
    --------
    dict : सत्यापन परिणाम
    """
    import numpy as np

    if नियम == 'साइन':
        # Spherical sine law: sin(a)/sin(A) = sin(b)/sin(B) = sin(c)/sin(C)
        अनुपात_a = np.sin(a) / np.sin(A) if np.sin(A) != 0 else None
        अनुपात_b = np.sin(b) / np.sin(B) if np.sin(B) != 0 else None
        अनुपात_c = np.sin(c) / np.sin(C) if np.sin(C) != 0 else None

        return {
            'नियम': 'साइन नियम',
            'sin(a)/sin(A)': अनुपात_a,
            'sin(b)/sin(B)': अनुपात_b,
            'sin(c)/sin(C)': अनुपात_c
        }

    elif नियम == 'कोसाइन':
        # Spherical cosine law: cos(a) = cos(b)cos(c) + sin(b)sin(c)cos(A)
        बायाँ = np.cos(a)
        दायाँ = np.cos(b) * np.cos(c) + np.sin(b) * np.sin(c) * np.cos(A)

        return {
            'नियम': 'कोसाइन नियम',
            'cos(a)': बायाँ,
            'cos(b)cos(c) + sin(b)sin(c)cos(A)': दायाँ,
            'अन्तर': abs(बायाँ - दायाँ)
        }


def क्रान्ति_गणना(रेखांश, अक्षांश, क्रान्तिवृत्त_कोण=23.44):
    """
    क्रान्ति (Declination) की गणना।

    Parameters:
    -----------
    रेखांश : float
        सूर्य/ग्रह का रेखांश (अंशों में)
    अक्षांश : float
        विषुववृत्त से अक्षांश
    क्रान्तिवृत्त_कोण : float
        क्रान्तिवृत्त का झुकाव (23.44°)

    Returns:
    --------
    float : क्रान्ति (अंशों में)
    """
    import numpy as np
    λ = np.radians(रेखांश)
    ε = np.radians(क्रान्तिवृत्त_कोण)

    क्रान्ति = np.arcsin(np.sin(λ) * np.sin(ε))

    return np.degrees(क्रान्ति)


# =============================================================================
# तात्कालिक गति (Instantaneous Velocity - Bhaskara II)
# =============================================================================

def तात्कालिक_गति(f, x, δ=0.001):
    """
    तात्कालिक गति की गणना (परिमित अन्तर विधि)।
    Bhaskara II's instantaneous velocity using finite differences.

    δ(sin θ) ≈ cos θ · δθ (for small δθ)

    Parameters:
    -----------
    f : function
        फलन (callable)
    x : float
        बिन्दु
    δ : float
        छोटा परिवर्तन (delta)

    Returns:
    --------
    dict : अवकलज सन्निकटन
    """
    # Forward difference
    आगे = (f(x + δ) - f(x)) / δ

    # Backward difference
    पीछे = (f(x) - f(x - δ)) / δ

    # Central difference (more accurate)
    केन्द्रीय = (f(x + δ) - f(x - δ)) / (2 * δ)

    return {
        'x': x,
        'δ': δ,
        'आगे_अन्तर': आगे,
        'पीछे_अन्तर': पीछे,
        'केन्द्रीय_अन्तर': केन्द्रीय,
        'f(x)': f(x),
        'f(x+δ)': f(x + δ),
        'f(x-δ)': f(x - δ)
    }


# =============================================================================
# नाडीवलय यन्त्र (Sundial & Shadow Calculations)
# =============================================================================

def छाया_गणना(शंकु, उन्नतांश):
    """
    छाया की लम्बाई की गणना।
    Shadow length calculation.

    छाया = शंकु × tan(zenith_angle) = शंकु / tan(altitude)

    Parameters:
    -----------
    शंकु : float
        ग्नोमोन (शंकु) की ऊँचाई
    उन्नतांश : float
        सूर्य की उन्नतांश (अंशों में, 0-90)

    Returns:
    --------
    dict : छाया और सम्बंधित गणनाएँ
    """
    import numpy as np

    if उन्नतांश <= 0 or उन्नतांश >= 90:
        return {'त्रुटि': 'उन्नतांश 0° और 90° के बीच होना चाहिए'}

    उन्नतांश_रेडियन = np.radians(उन्नतांश)
    ज्या = np.sin(उन्नतांश_रेडियन)
    कोटिज्या = np.cos(उन्नतांश_रेडियन)

    # छाया = शंकु / tan(उन्नतांश)
    छाया = शंकु / np.tan(उन्नतांश_रेडियन)

    # कर्ण (hypotenuse)
    कर्ण = शंकु / ज्या

    return {
        'शंकु': शंकु,
        'उन्नतांश': उन्नतांश,
        'छाया': छाया,
        'कर्ण': कर्ण,
        'अनुपात_छाया_शंकु': छाया / शंकु,
        'ज्या': ज्या,
        'कोटिज्या': कोटिज्या
    }


def छाया_से_उन्नतांश(शंकु, छाया):
    """
    छाया से सूर्य की उन्नतांश ज्ञात करना।

    Parameters:
    -----------
    शंकु : float
        ग्नोमोन की ऊँचाई
    छाया : float
        छाया की लम्बाई

    Returns:
    --------
    float : उन्नतांश (अंशों में)
    """
    import numpy as np

    उन्नतांश_रेडियन = np.arctan(शंकु / छाया)
    return np.degrees(उन्नतांश_रेडियन)


def समय_से_छाया(घंटा, अक्षांश, क्रान्ति):
    """
    समय से छाया की गणना (पञ्चाङ्ग विधि)।

    Parameters:
    -----------
    घंटा : float
        स्थानीय समय (0-24)
    अक्षांश : float
        स्थान का अक्षांश (अंशों में)
    क्रान्ति : float
        सूर्य की क्रान्ति (अंशों में)

    Returns:
    --------
    dict : उन्नतांश और अजिमथ
    """
    import numpy as np

    # होरा कोण (Hour angle)
    होरा_कोण = (घंटा - 12) * 15  # 1 घंटा = 15°

    φ = np.radians(अक्षांश)
    δ = np.radians(क्रान्ति)
    H = np.radians(होरा_कोण)

    # उन्नतांश (Altitude)
    sin_alt = np.sin(φ) * np.sin(δ) + np.cos(φ) * np.cos(δ) * np.cos(H)
    उन्नतांश = np.degrees(np.arcsin(sin_alt))

    # अजिमथ (Azimuth)
    cos_az = (np.sin(δ) - np.sin(φ) * sin_alt) / (np.cos(φ) * np.cos(np.arcsin(sin_alt)))
    अजिमथ = np.degrees(np.arccos(np.clip(cos_az, -1, 1)))

    if होरा_कोण > 0:
        अजिमथ = 360 - अजिमथ

    return {
        'घंटा': घंटा,
        'होरा_कोण': होरा_कोण,
        'उन्नतांश': उन्नतांश,
        'अजिमथ': अजिमथ
    }


# =============================================================================
# पाणिनीय व्याकरण (Paninian Grammar)
# =============================================================================

def प्रत्याहार_निकालें(आदि, अन्त, शिवसूत्राणि=None):
    """
    प्रत्याहार निकालना (Pratyahara extraction from Shiva Sutras)।

    माहेश्वर सूत्राणि से वर्ण समूह निकालना।

    Parameters:
    -----------
    आदि : str
        प्रारम्भिक वर्ण
    अन्त : str
        अन्तिम इत् वर्ण
    शिवसूत्राणि : list, optional
        14 शिव सूत्र (default: standard Maheshvara sutras)

    Returns:
    --------
    dict : प्रत्याहार और वर्ण सूची

    Example:
    --------
    >>> प्रत्याहार_निकालें('अ', 'ण्')  # अण् = all vowels
    """
    if शिवसूत्राणि is None:
        # 14 माहेश्वर सूत्राणि
        शिवसूत्राणि = [
            'अइउण्',
            'ऋऌक्',
            'एओङ्',
            'ऐऔच्',
            'हयवरट्',
            'लण्',
            'ञमङणनम्',
            'झभञ्',
            'घढधष्',
            'जबगडदश्',
            'खफछठथचटतव्',
            'कपय्',
            'शषसर्',
            'हल्'
        ]

    # सभी वर्ण और इत् चिह्न एकत्र करना
    वर्ण_सूची = []
    इत्_सूची = []

    for सूत्र in शिवसूत्राणि:
        for i, अक्षर in enumerate(सूत्र):
            if अक्षर == '्':
                # इत् वर्ण (marker)
                if i > 0:
                    इत्_सूची.append(सूत्र[i-1])
            else:
                वर्ण_सूची.append(अक्षर)

    # प्रत्याहार निकालना
    प्रारम्भ_मिला = False
    निष्कर्ष = []

    for i, वर्ण in enumerate(वर्ण_सूची):
        if वर्ण == आदि:
            प्रारम्भ_मिला = True

        if प्रारम्भ_मिला and वर्ण not in ['्'] and not वर्ण.endswith('्'):
            निष्कर्ष.append(वर्ण)

        if वर्ण == अन्त or (i < len(वर्ण_सूची) - 1 and वर्ण_सूची[i+1] == '्' and वर्ण == अन्त):
            break

    return {
        'प्रत्याहार': आदि + अन्त,
        'आदि': आदि,
        'अन्त': अन्त,
        'वर्ण': ''.join(निष्कर्ष),
        'संख्या': len(निष्कर्ष)
    }
